  refresh方法是一切实例化的开始，也是容器实例化的过程中最重要的一步

    1.prepareRefresh();刷新容器，记录容器启动时间和标记

    2.obtainFreshBeanFactory(); 给工厂设置一个id，并获得该工厂

    3.prepareBeanFactory(beanFactory); beanfactory预准备
        1) 给beanfactory设置属性值
            beanFactory.setBeanClassLoader(getClassLoader());
            beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
            beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
        2) 向beanfactory中注册两个后置处理器
            beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
            beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));
        3）注册三个容器所需要的单实例bean
    4.invokeBeanFactoryPostProcessors(beanFactory);  执行BeanFactoryPostProcessor
        1)invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors)  执行beanfactory的后置处理器
            ①List<BeanFactoryPostProcessor> beanFactoryPostProcessors  还没搞明白

            ② List<BeanFactoryPostProcessor> regularPostProcessors = new ArrayList<>();
               List<BeanDefinitionRegistryPostProcessor> registryProcessors = new ArrayList<>();
               BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，但是它们两个的执行时机不同，
               BeanFactoryPostProcessor执行时机：在应用程序上下文的标准初始化之后修改它的内部bean工厂。所有bean定义都已加载，但还没有实例化bean。
               BeanDefinitionRegistryPostProcessor执行时机：在应用程序上下文的标准初始化之后修改它的内部bean定义注册表。所有常规bean定义都已加载，但还没有实例化任何bean。

            新增1、根据类型获取bean的名称  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
                String[] getBeanNamesForType()
                    -->  RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                        -->  RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName); 一开始 mergedBeanDefinitions 这个list为空
                        -->  getMergedBeanDefinition(beanName, getBeanDefinition(beanName)); 循环遍历的将AnnotatedBeanDefinitionReader实例化阶段添加的5个RootBeanDefinition和我们的配置类添加到
                                mergedBeanDefinitions数组中。



                小结：会循环遍历处理所有的类，如果是spring容器的内部类，则会给内部类设置scope等
                      到目前为止，容器还未实例化任何beanDefinition，还没有触发getBean()方法。
                      我们自定义的类，也只有配置类被扫描进了容器，其他类还没有被加载


            ③ 执行BeanDefinitionRegistryPostProcessor：
                A、 根据类型获取所有的BeanDefinitionRegistryPostProcessor，首先获取实现了PriorityOrdered优先级的BeanDefinitionRegistryPostProcessor，调用getBean(ppName, BeanDefinitionRegistryPostProcessor.class)
                方法，创建对象，并将创建好的对象添加到currentRegistryProcessors集合中。
                B、invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 观察者模式，对currentRegistryProcessors集合中的对象统一调用postProcessBeanDefinitionRegistry(registry);
                    postProcessor.postProcessBeanDefinitionRegistry(registry);   这个方法要好好看看！！！！

                C、获取实现了Ordered接口的BeanDefinitionRegistryPostProcessor，调用getBean(ppName, BeanDefinitionRegistryPostProcessor.class)方法，创建对象，并将创建好的对象添加到currentRegistryProcessors集合中。
                D、invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 观察者模式，对currentRegistryProcessors集合中的对象统一调用postProcessBeanDefinitionRegistry(registry);
                    postProcessor.postProcessBeanDefinitionRegistry(registry);   这个方法要好好看看！！！！
                E、处理没有实现PriorityOrdered和Ordered的BeanDefinitionRegistryPostProcessor

    5.invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
        1)beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));
            向beanFactory中添加一个BeanPostProcessor
        2)查找出实现了BeanPostProcessor接口的BeanPostProcessor,并将其实例化
        3）registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);将实例化的BeanPostProcessor添加到beanfactory中。
        4)



    6.finishBeanFactoryInitialization(beanFactory);初始化所有未实例化的bean
        1) beanFactory.preInstantiateSingletons();实例化所有未加载的bean
            A 判断是否是非抽象的，单例的，非懒加载的
                a)判断是否是factoryBean，如果是factoryBean，则..............
                b) 如果不是factoryBean，则直接调用getBean()方法

        2)smartSingleton.afterSingletonsInstantiated();
